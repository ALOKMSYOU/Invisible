local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")

local LP = Players.LocalPlayer
local Cam = workspace.CurrentCamera
local Mouse = LP:GetMouse()

local UI_SCALE = 1/1.4
local AUTO_RADIUS = 30
local MOVE_SNAP = 1
local ROT_SNAP = 15

local holdDistance = 25
local throwForce = 200

local grabbed = {}
local frozen = {}
local selected = {}
local highlights = {}
local handles = {}

local autoGrabNPC = false
local autoGrabPart = false
local autoFreeze = false
local autoThrow = false
local autoGrabFreeze = false
local highlightOn = true

local currentTool = "NONE"

local initialCFrames = {} 
local initialPositions = {}

local gui = Instance.new("ScreenGui")
pcall(function() gui.Parent = CoreGui end)
if gui.Parent ~= CoreGui then gui.Parent = LP.PlayerGui end
gui.Name = "TelekinesisUI_F3X"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local cross = Instance.new("Frame", gui)
cross.Size = UDim2.fromOffset(6,6)
cross.Position = UDim2.fromScale(0.5,0.5)
cross.AnchorPoint = Vector2.new(0.5,0.5)
cross.BackgroundColor3 = Color3.new(1,1,1)
Instance.new("UICorner",cross).CornerRadius = UDim.new(1,0)

local targetHL = Instance.new("Highlight", gui)
targetHL.FillTransparency = 0.6
targetHL.OutlineColor = Color3.fromRGB(255,255,255)

local main = Instance.new("Frame", gui)
main.Size = UDim2.fromScale(0.32*UI_SCALE, 0.75*UI_SCALE)
main.Position = UDim2.fromScale(0.03, 0.18)
main.BackgroundColor3 = Color3.fromRGB(20,20,20)
main.Active = true
main.Draggable = true
Instance.new("UICorner",main).CornerRadius = UDim.new(0,14)

local title = Instance.new("TextLabel", main)
title.Size = UDim2.new(1,0,0,32)
title.Text = "TELEKINESIS + F3X (NO ANCHORED)"
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.TextColor3 = Color3.new(1,1,1)
title.BackgroundTransparency = 1

local pages = {}

local function createPage()
	local f = Instance.new("ScrollingFrame", main)
	f.Position = UDim2.new(0.03,0,0,36)
	f.Size = UDim2.new(0.94,0,1,-40)
	f.ScrollBarThickness = 6
	f.Visible = false
	f.BackgroundColor3 = Color3.fromRGB(30,30,30)
	f.BorderSizePixel = 0
	
	local layout = Instance.new("UIListLayout", f)
	layout.Padding = UDim.new(0,5)
	
	layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		f.CanvasSize = UDim2.new(0,0,0,layout.AbsoluteContentSize.Y+6)
	end)
	return f
end

pages.main = createPage()
pages.move = createPage()

local function showPage(name)
	for k,v in pairs(pages) do
		v.Visible = (k == name)
	end
end
showPage("main")

-- ฟังก์ชันตรวจสอบ Part (ป้องกันการ Grab ของที่ Anchored)
local function isValidPart(p)
	if not p or not p:IsA("BasePart") then return false end
	if p.Anchored then return false end -- บรรทัดนี้คือหัวใจสำคัญ: ถ้าถูกล็อกตำแหน่ง จะไม่ผ่านเงื่อนไข
	return true
end

local function getTarget()
	local rp = RaycastParams.new()
	rp.FilterType = Enum.RaycastFilterType.Exclude
	rp.FilterDescendantsInstances = {LP.Character, workspace.CurrentCamera}
	local r = workspace:Raycast(
		Cam.CFrame.Position,
		Cam.CFrame.LookVector * 500,
		rp
	)
	-- ตรวจสอบก่อนส่งคืนค่า target ว่า Anchored หรือไม่
	if r and r.Instance and isValidPart(r.Instance) then
		return r.Instance
	end
	return nil
end

local function clearAllHandles()
	for p, hSet in pairs(handles) do
		if hSet.move then hSet.move:Destroy() end
		if hSet.rot then hSet.rot:Destroy() end
	end
	handles = {}
end

local function createHandles(p)
	clearAllHandles()
	if not p or not isValidPart(p) then return end -- ป้องกัน Anchored Part
	
	local mh = Instance.new("Handles")
	mh.Adornee = p
	mh.Style = Enum.HandlesStyle.Resize
	mh.Color3 = Color3.fromRGB(255,255,100)
	mh.Parent = gui
	mh.Visible = (currentTool == "MOVE")
	
	local ah = Instance.new("ArcHandles")
	ah.Adornee = p
	ah.Parent = gui
	ah.Visible = (currentTool == "ROTATE")
	
	mh.MouseButton1Down:Connect(function()
		initialPositions = {}
		for part in pairs(selected) do
			if grabbed[part] and not part.Anchored then -- ตรวจสอบอีกชั้น
				initialPositions[part] = grabbed[part].bp.Position
			end
		end
	end)

	mh.MouseDrag:Connect(function(face, dist)
		local axisVec
		if face == Enum.NormalId.Top then axisVec = p.CFrame.UpVector
		elseif face == Enum.NormalId.Bottom then axisVec = -p.CFrame.UpVector
		elseif face == Enum.NormalId.Right then axisVec = p.CFrame.RightVector
		elseif face == Enum.NormalId.Left then axisVec = -p.CFrame.RightVector
		elseif face == Enum.NormalId.Front then axisVec = p.CFrame.LookVector
		elseif face == Enum.NormalId.Back then axisVec = -p.CFrame.LookVector
		end
		
		local snappedDist = math.round(dist / MOVE_SNAP) * MOVE_SNAP
		local offset = axisVec * snappedDist
		
		for part in pairs(selected) do
			if grabbed[part] and initialPositions[part] and not part.Anchored then
				grabbed[part].bp.Position = initialPositions[part] + offset
			end
		end
	end)
	
	ah.MouseButton1Down:Connect(function()
		initialCFrames = {}
		for part in pairs(selected) do
			if grabbed[part] and not part.Anchored then
				initialCFrames[part] = grabbed[part].bg.CFrame
			end
		end
	end)

	ah.MouseDrag:Connect(function(axis, angle)
		local deg = math.deg(angle)
		local snappedDeg = math.round(deg / ROT_SNAP) * ROT_SNAP
		local finalRad = math.rad(snappedDeg)
		
		local axisVec = Vector3.new(0,0,0)
		if axis == Enum.Axis.X then axisVec = Vector3.new(1,0,0)
		elseif axis == Enum.Axis.Y then axisVec = Vector3.new(0,1,0)
		elseif axis == Enum.Axis.Z then axisVec = Vector3.new(0,0,1)
		end
		
		local rotationCFrame = CFrame.Angles(axisVec.X * finalRad, axisVec.Y * finalRad, axisVec.Z * finalRad)
		local centerCF = initialCFrames[p]
		
		for part in pairs(selected) do
			if grabbed[part] and initialCFrames[part] and not part.Anchored then
				local relativeCF = centerCF:Inverse() * initialCFrames[part]
				grabbed[part].bg.CFrame = centerCF * rotationCFrame * relativeCF
				
				local relativePos = initialCFrames[part].Position - centerCF.Position
				local rotatedPos = centerCF.Position + (centerCF * rotationCFrame):VectorToWorldSpace(centerCF:VectorToObjectSpace(relativePos))
				grabbed[part].bp.Position = rotatedPos
			end
		end
	end)
	
	handles[p] = {move = mh, rot = ah}
end

local function grabPart(p)
	if not isValidPart(p) then return end -- ตรวจสอบ Anchored
	if grabbed[p] then return end

	local bp = Instance.new("BodyPosition")
	bp.MaxForce = Vector3.new(1e6,1e6,1e6)
	bp.P = 10000
	bp.Position = p.Position
	bp.Parent = p
	
	local bg = Instance.new("BodyGyro")
	bg.MaxTorque = Vector3.new(1e6,1e6,1e6)
	bg.P = 10000
	bg.CFrame = p.CFrame
	bg.Parent = p
	
	grabbed[p] = {bp = bp, bg = bg}
end

local function setHighlight(p, state)
	if state then
		if not highlights[p] and isValidPart(p) then
			local hl = Instance.new("Highlight")
			hl.Adornee = p
			hl.FillTransparency = 0.4
			hl.OutlineColor = Color3.fromRGB(255,255,0)
			hl.Parent = gui
			highlights[p] = hl
		end
	else
		if highlights[p] then
			highlights[p]:Destroy()
			highlights[p] = nil
		end
	end
end

local function btn(page, text, cb)
	local b = Instance.new("TextButton", page)
	b.Size = UDim2.new(1,0,0,26)
	b.Text = text
	b.Font = Enum.Font.Gotham
	b.TextSize = 12
	b.TextColor3 = Color3.new(1,1,1)
	b.BackgroundColor3 = Color3.fromRGB(70,70,70)
	Instance.new("UICorner",b)
	b.MouseButton1Click:Connect(function() cb(b) end)
	return b
end

local function label(page, text)
	local l = Instance.new("TextLabel", page)
	l.Size = UDim2.new(1,0,0,20)
	l.BackgroundTransparency = 1
	l.Text = text
	l.Font = Enum.Font.GothamBold
	l.TextColor3 = Color3.fromRGB(150,150,150)
	l.TextSize = 11
	return l
end

btn(pages.main, "GRAB (LOOK)", function()
	grabPart(getTarget())
end)

btn(pages.main, "DROP (LOOK)", function()
	local t=getTarget()
	if t and grabbed[t] then
		grabbed[t].bp:Destroy()
		grabbed[t].bg:Destroy()
		grabbed[t]=nil
		frozen[t]=nil
		selected[t]=nil
		setHighlight(t,false)
		clearAllHandles()
	end
end)

btn(pages.main, "DROP ALL", function()
	for p, objs in pairs(grabbed) do 
		objs.bp:Destroy() 
		objs.bg:Destroy()
	end
	grabbed={}
	frozen={}
	selected={}
	for p in pairs(highlights) do setHighlight(p,false) end
	clearAllHandles()
end)

btn(pages.main, "FREEZE (LOOK)", function()
	local t=getTarget()
	if t and grabbed[t] then 
		frozen[t]=true 
	end
end)

btn(pages.main, "UNFREEZE (LOOK)", function()
	local t=getTarget()
	if t then
		frozen[t]=nil
		selected[t]=nil
		setHighlight(t,false)
	end
end)

btn(pages.main, "UNFREEZE ALL", function()
	frozen={}
	selected={}
	for p in pairs(highlights) do setHighlight(p,false) end
	clearAllHandles()
end)

label(pages.main, "--- AUTO SETTINGS ---")

btn(pages.main, "AUTO GRAB NPC", function(b)
	autoGrabNPC = not autoGrabNPC
	b.Text = "AUTO GRAB NPC : "..(autoGrabNPC and "ON" or "OFF")
end)

btn(pages.main, "AUTO GRAB PART", function(b)
	autoGrabPart = not autoGrabPart
	b.Text = "AUTO GRAB PART : "..(autoGrabPart and "ON" or "OFF")
end)

btn(pages.main, "AUTO FREEZE", function(b)
	autoFreeze = not autoFreeze
	b.Text = "AUTO FREEZE : "..(autoFreeze and "ON" or "OFF")
end)

btn(pages.main, "AUTO THROW", function(b)
	autoThrow = not autoThrow
	b.Text = "AUTO THROW : "..(autoThrow and "ON" or "OFF")
end)

label(pages.main, "--- ACTIONS ---")

btn(pages.main, "THROW (LOOK)", function()
	for p, objs in pairs(grabbed) do
		p.AssemblyLinearVelocity = Cam.CFrame.LookVector * throwForce
		objs.bp:Destroy()
		objs.bg:Destroy()
	end
	grabbed={}
	frozen={}
	selected={}
	for p in pairs(highlights) do setHighlight(p,false) end
	clearAllHandles()
end)

local distLabel = btn(pages.main, "DISTANCE : "..holdDistance, function() end)
btn(pages.main, "+ DIST", function()
	holdDistance+=5
	distLabel.Text = "DISTANCE : "..holdDistance
end)
btn(pages.main, "- DIST", function()
	holdDistance = math.max(1, holdDistance-5)
	distLabel.Text = "DISTANCE : "..holdDistance
end)

btn(pages.main, "HIGHLIGHT", function(b)
	highlightOn = not highlightOn
	b.Text = "HIGHLIGHT : "..(highlightOn and "ON" or "OFF")
end)

btn(pages.main, "▶ MOVE / ROTATE MODE", function()
	showPage("move")
end)

btn(pages.main, "DESTROY UI", function()
	for p, objs in pairs(grabbed) do 
		objs.bp:Destroy() 
		objs.bg:Destroy()
	end
	gui:Destroy()
end)

local list = Instance.new("ScrollingFrame", pages.move)
list.Size = UDim2.new(1,0,0,120)
list.ScrollBarThickness = 6
list.BackgroundColor3 = Color3.fromRGB(35,35,35)
list.BorderSizePixel = 0

local ll = Instance.new("UIListLayout", list)
ll.Padding = UDim.new(0,4)

local function refreshList()
	for _,c in ipairs(list:GetChildren()) do
		if c:IsA("TextButton") then c:Destroy() end
	end
	for p in pairs(frozen) do
		if p and p.Parent and not p.Anchored then
			local b = Instance.new("TextButton", list)
			b.Size = UDim2.new(1,0,0,26)
			b.Text = p.Name
			b.Font = Enum.Font.Gotham
			b.TextSize = 12
			b.TextColor3 = Color3.new(1,1,1)
			b.BackgroundColor3 = selected[p] and Color3.fromRGB(120,120,0) or Color3.fromRGB(70,70,70)
			Instance.new("UICorner",b)
			b.MouseButton1Click:Connect(function()
				selected[p] = not selected[p]
				setHighlight(p, selected[p])
				
				local anySelected = false
				local lastSelected = nil
				for part in pairs(selected) do
					anySelected = true
					lastSelected = part
				end
				
				if anySelected then
					createHandles(lastSelected)
				else
					clearAllHandles()
				end
				refreshList()
			end)
		end
	end
end

btn(pages.move, "REFRESH LIST", refreshList)
btn(pages.move, "SELECT ALL", function()
	local last = nil
	for p in pairs(frozen) do 
		if not p.Anchored then
			selected[p] = true 
			setHighlight(p, true)
			last = p
		end
	end
	if last then createHandles(last) end
	refreshList()
end)

btn(pages.move, "UNSELECT ALL", function()
	for p in pairs(selected) do setHighlight(p, false) end
	selected = {}
	clearAllHandles()
	refreshList()
end)

label(pages.move, "--- TOOLS (MULTI-EDIT) ---")

local toolBtn = btn(pages.move, "CURRENT TOOL: NONE", function(b)
	if currentTool == "NONE" then currentTool = "MOVE"
	elseif currentTool == "MOVE" then currentTool = "ROTATE"
	else currentTool = "NONE" end
	b.Text = "CURRENT TOOL: "..currentTool
	b.BackgroundColor3 = (currentTool=="NONE") and Color3.fromRGB(70,70,70) or Color3.fromRGB(0,100,200)
	
	local lastSelected = nil
	for p in pairs(selected) do lastSelected = p end
	if lastSelected then createHandles(lastSelected) end
end)

label(pages.move, "--- SETTINGS ---")

local mSnapBtn = btn(pages.move, "MOVE STEP (SNAP): "..MOVE_SNAP, function(b)
	if MOVE_SNAP == 0.1 then MOVE_SNAP = 0.5
	elseif MOVE_SNAP == 0.5 then MOVE_SNAP = 1
	elseif MOVE_SNAP == 1 then MOVE_SNAP = 5
	elseif MOVE_SNAP == 5 then MOVE_SNAP = 10
	else MOVE_SNAP = 0.1 end
	b.Text = "MOVE STEP (SNAP): "..MOVE_SNAP
end)

local rSnapBtn = btn(pages.move, "ROTATE STEP (SNAP): "..ROT_SNAP, function(b)
	if ROT_SNAP == 1 then ROT_SNAP = 5
	elseif ROT_SNAP == 5 then ROT_SNAP = 15
	elseif ROT_SNAP == 15 then ROT_SNAP = 45
	elseif ROT_SNAP == 45 then ROT_SNAP = 90
	else ROT_SNAP = 1 end
	b.Text = "ROTATE STEP (SNAP): "..ROT_SNAP
end)

btn(pages.move, "◀ BACK", function()
	showPage("main")
end)

RunService.RenderStepped:Connect(function()
	local t = getTarget()
	-- Highlight จะไม่แสดงถ้า Part นั้น Anchored (จัดการโดย getTarget)
	targetHL.Adornee = highlightOn and t or nil

	for p, objs in pairs(grabbed) do
		if not p or not p.Parent or p.Anchored then -- ถ้าอยู่ดีๆ Part โดน Anchor ระหว่างถือ ให้หลุดทันที
			if objs.bp then objs.bp:Destroy() end
			if objs.bg then objs.bg:Destroy() end
			grabbed[p] = nil
			frozen[p] = nil
			selected[p] = nil
			setHighlight(p, false)
		elseif not frozen[p] then
			objs.bp.Position = Cam.CFrame.Position + Cam.CFrame.LookVector * holdDistance
			objs.bg.CFrame = p.CFrame
		end
	end
end)

local toggleBtn = Instance.new("TextButton", gui)
toggleBtn.Size = UDim2.fromOffset(40, 40)
toggleBtn.Position = UDim2.new(0.03, 0, 0.18, -45)
toggleBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
toggleBtn.Text = "[-]"
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextColor3 = Color3.new(1, 1, 1)
toggleBtn.TextSize = 18

local uiCorner = Instance.new("UICorner", toggleBtn)
uiCorner.CornerRadius = UDim.new(0, 8)

local isMinimized = false
toggleBtn.MouseButton1Click:Connect(function()
	isMinimized = not isMinimized
	main.Visible = not isMinimized
	toggleBtn.Text = isMinimized and "[+]" or "[-]"
end)

toggleBtn.Active = true
toggleBtn.Draggable = true

loadstring(game:HttpGet("https://raw.githubusercontent.com/randomstring0/Qwerty/main/qwerty1.lua"))()
